{"version":3,"file":"vuex-cache.min.js","sources":["../src/index.js"],"sourcesContent":["const isVuexStore = obj =>\n  'dispatch' in obj && typeof obj.dispatch === 'function'\n\n// convert string or obj to string\nconst toString = arg => (typeof arg === 'string' ? arg : JSON.stringify(arg))\n\n// convert arguments to string\nconst argsToString = args => {\n  let type = toString(args[0])\n  if (args[1]) {\n    type = `${type}:${toString(args[1])}`\n  }\n  return type\n}\n\n// parse timeout prop in option\nconst getTimeout = (args, option) => {\n  if (args.length === 1 && args[0].timeout) {\n    return args[0].timeout\n  }\n  if (args.length === 3 && args[2].timeout) {\n    return args[2].timeout\n  }\n  if (option && option.timeout) {\n    return option.timeout\n  }\n  return 0\n}\n\nconst cachePlugin = (store, option) => {\n  const cache = new Map()\n  // use another map to store timeout for each type\n  const timeoutCache = new Map()\n\n  cache.dispatch = (...args) => {\n    const type = argsToString(args)\n\n    const timeout = getTimeout(args, option)\n    if (timeout) {\n      const now = Date.now()\n      if (!timeoutCache.has(type)) {\n        timeoutCache.set(type, now)\n      } else {\n        const timeoutOfCurrentType = timeoutCache.get(type)\n        // console.log(now - timeout, timeoutOfCurrentType)\n        if (now - timeout > timeoutOfCurrentType) {\n          cache.delete(type)\n          timeoutCache.delete(type)\n        }\n      }\n    }\n\n    if (!cache.has(type)) {\n      const action = store.dispatch.apply(store, args).catch(error => {\n        cache.delete(type)\n        return Promise.reject(error)\n      })\n\n      cache.set(type, action)\n    }\n    return cache.get(type)\n  }\n\n  const _has = cache.has.bind(cache)\n  cache.has = (...args) => {\n    const key = argsToString(args)\n    return _has(toString(key))\n  }\n\n  const _delete = cache.delete.bind(cache)\n  cache.delete = (...args) => {\n    const key = argsToString(args)\n    return _delete(toString(key))\n  }\n\n  store.cache = cache\n}\n\nconst resolveParams = args => {\n  if (!isVuexStore(args)) {\n    return store => cachePlugin(store, args)\n  }\n  return cachePlugin(args)\n}\n\n// expose plugin as default\nexport default resolveParams\n\n// expose action enhancer\nexport function cacheAction(action) {\n  return function cacheEnhancedAction(context, payload) {\n    cachePlugin(context)\n    return action(context, payload)\n  }\n}\n"],"names":["toString","arg","JSON","stringify","argsToString","args","type","cachePlugin","store","option","cache","Map","timeoutCache","dispatch","timeout","length","now","Date","has","get","delete","set","action","apply","catch","error","Promise","reject","_has","bind","key","_delete","obj","context","payload"],"mappings":";;;;;4LAAA,IAIMA,EAAW,SAAAC,SAAuB,iBAARA,EAAmBA,EAAMC,KAAKC,UAAUF,IAGlEG,EAAe,SAAAC,OACfC,EAAON,EAASK,EAAK,WACrBA,EAAK,KACPC,YAAUA,cAAQN,EAASK,EAAK,MAE3BC,GAiBHC,EAAc,SAACC,EAAOC,OACpBC,EAAQ,IAAIC,IAEZC,EAAe,IAAID,IAEzBD,EAAMG,SAAW,sCAAIR,2BAAAA,sBAlBHA,EAAMI,EAmBhBH,EAAOF,EAAaC,GAEpBS,GArBgBL,EAqBWA,EApBf,KADFJ,EAqBWA,GApBpBU,QAAgBV,EAAK,GAAGS,QACxBT,EAAK,GAAGS,QAEG,IAAhBT,EAAKU,QAAgBV,EAAK,GAAGS,QACxBT,EAAK,GAAGS,QAEbL,GAAUA,EAAOK,QACZL,EAAOK,QAET,MAYDA,EAAS,KACLE,EAAMC,KAAKD,SACZJ,EAAaM,IAAIZ,GAGSM,EAAaO,IAAIb,GAE1CU,EAAMF,IACRJ,EAAMU,OAAOd,GACbM,EAAaQ,OAAOd,SANtBM,EAAaS,IAAIf,EAAMU,OAWtBN,EAAMQ,IAAIZ,GAAO,KACdgB,EAASd,EAAMK,SAASU,MAAMf,EAAOH,GAAMmB,MAAM,SAAAC,UACrDf,EAAMU,OAAOd,GACNoB,QAAQC,OAAOF,KAGxBf,EAAMW,IAAIf,EAAMgB,UAEXZ,EAAMS,IAAIb,QAGbsB,EAAOlB,EAAMQ,IAAIW,KAAKnB,GAC5BA,EAAMQ,IAAM,sCAAIb,2BAAAA,sBACRyB,EAAM1B,EAAaC,UAClBuB,EAAK5B,EAAS8B,SAGjBC,EAAUrB,EAAMU,OAAOS,KAAKnB,GAClCA,EAAMU,OAAS,sCAAIf,2BAAAA,sBACXyB,EAAM1B,EAAaC,UAClB0B,EAAQ/B,EAAS8B,KAG1BtB,EAAME,MAAQA,aAGM,SAAAL,SA7EpB,aADkB2B,EA+ED3B,IA9E4B,mBAAjB2B,EAAInB,SAiFzBN,EAAYF,GAFV,SAAAG,UAASD,EAAYC,EAAOH,IAhFnB,IAAA2B,iBAyFb,SAAqBV,UACnB,SAA6BW,EAASC,UAC3C3B,EAAY0B,GACLX,EAAOW,EAASC"}